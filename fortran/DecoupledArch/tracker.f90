program tracker

use mpi

IMPLICIT NONE

INTEGER :: fin_step = 500 !Number of steps the particle takes
INTEGER :: curr_step = 0 !Current step the particle is on

integer rank, ierr !Ranking in the world, error variable

INTEGER st_intercomm1 !Intercommunicator between the solver group and the tracker group

REAL :: x1 = 0 !x variable for quadrant 1
REAL :: y1 = 0 !y variable for quadrant 1
REAL :: x2 = 0 !x variable for quadrant 2
REAL :: y2 = 0 !y variable for quadrant 2
REAL :: x3 = 0 !x variable for quadrant 3
REAL :: y3 = 0 !y variable for quadrant 3
REAL :: x4 = 0 !x variable for quadrant 4
REAL :: y4 = 0 !y variable for quadrant 4

INTEGER intercomm_rank !Rank of the process in the intercommunicator

!color variable used to split the MPI_WORLD_COMM, solve_track_comm is the communicator generated by the split,
!status is simply the status of the receive call
INTEGER color, solve_track_comm, status(MPI_STATUS_SIZE)

INTEGER :: tag = 22 !Tag of the messages used throughout the program

REAL :: particle_pos_x = 1. !Initial Particle X-Coordinate
REAL :: particle_pos_y = 1. !Initial Particle Y-Coordinate

INTEGER :: tracker_num = 2 !Number of trackers
INTEGER :: solver_num = 4 !Number of solvers

character(len=1024) :: filename !Character array to store the filename
INTEGER :: filetag = 91 !Tag of the I/O


!LESSON LEARNED: TAGS ARE REALLY IMPORTANT. THEY MUST BE THE SAME THROUGHOUT THE COMMUNICATION CHANNELS.

! In essence, we create an intercommunicator. However, the intercommunicator actually produces 2 different communicators.
!Each of these communicators will be sending something from a certain rank within that communicator. In this case, we have 2 processes.
!One is rank 0, the other is rank 1. We use SPLIT to create 2 new communicators, each housing one process. Then, we call
!CREATE INTERCOMMUNICATOR for each, differently depending on the rank. If it is of rank 0, then we create intercomm1. If it is of rank 1,
!then we create intercomm2. Note that in every communication (intercomm create, send, recv), we always use the same tag. We then transmit
!the value of x from using the local intercommunicator to the rank of the value in the other intercommunicator. So we call send using the
!local intercommunicator produced (because NOTE that this is the only one that even exists on this machine). The rank we specify though,
!is the rank of the process in the OTHER communicator.

!Standard opening
CALL MPI_INIT(ierr)
CALL MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)
!write(*,*) "TRACKER RANK: ", rank

!Color of trackers is 0
color = 0

!write(*,*) "color: ", color

!Split the world into two communicators: the trackers and the solvers
CALL MPI_Comm_split(MPI_COMM_WORLD, color, rank, solve_track_comm, ierr);

!Find the rank within the tracker group and create a filename with that
CALL MPI_Comm_rank(solve_track_comm, intercomm_rank, ierr)
write (filename, "(A5,I1)") "file_", intercomm_rank
filetag = filetag + intercomm_rank !Generate the unique filetag for this txt file and tracker
open(filetag, file = filename, status = 'REPLACE') !Open the I/O channel

!write(*,*) filename

! Create the intercommunicator: MPI_INTERCOMM_CREATE creates an intercommunicator between two groups. It requires a leader process in each group and
! A communicator that contains both of these processes. It should be noted that while the rank of the local process here is the rank within the group,
! The rank of the remote leader is the rank within the bridging communicator
! 1) Solve_Track_comm is the local group we are hoping to use to communicate (the tracker group, which is running on this process)
! 2) 0 is the leader rank of the communicator in this group (the tracker group). This is hardcoded and it is arbitrarily chosen to be the 0th rank
! (also gives us more flexibility since there will basically always be a 0th rank)
! 3) MPI_COMM_WORLD is the bridging communicator. This is the communicator that both the leader processes share. We know this contains the solver
! leader because MPI_COMM_WORLD contains all of the processes
! 4) 2 is the rnak of the leader in MPI_COMM_WORLD. This argument is the rank of the leader in the bridging communicator.
! There are a couple different ways to decide on the leader rank of a communicator and then send this to the other group (without an intercommunicator to start)
! I chose to create a bash script to handle the running of these processes. The way I set it up, this tracker program is run on rank 0 and rank 1 processes
! In the MPI_COMM_WORLD. This rank is known in the bash environment and can be used to set up the start. As a result, we know that rank 2 will not be used
! And so rank 2 is chosen arbitrarily as the leader communicator
! Tag is simply the tag used for all messages passed through the intercommunicator
! st_intercomm1 is the handle of the new intercommunicator
! ierr is the standard error variable
CALL MPI_INTERCOMM_CREATE(solve_track_comm, 0, MPI_COMM_WORLD, 2, tag, st_intercomm1, ierr)
!write(*,*) "INTERCOM CREATED"
 !Tracker group is the group we want to link, 0 is the rank of the leader (arbitrarily chosen), MPI_COMM_WORLD is the communicator in which the two "leader"
 ! Processes share (that is, the tracker and solver processes).
!     IN MPI_COMM_WORLD, the rank is 0, and the rank of the tracker is 1. So in the above, we use 1 as the leader rank of the peer communicator.

! Find the rank of this local process within the intercommunicator
CALL MPI_Comm_rank(st_intercomm1, intercomm_rank, ierr)

!write(*,*) "intercomm rank: ", rank, intercomm_rank

! Time step loop. Here, we receive the vector for each time step
DO WHILE (curr_step<fin_step)

! MPI_RECV receives messages from the intercommunicator. MPI_RECV specifically recieves the
! x and y components of the vector components of the velocities in each of the quadrants, calculated
! by the solver processes. 1 and MPI Real mean that the received message should be of size 1 and a real number.
! 0/1/2/3 are the ranks of the solver processes IN THE SOLVER GROUP, tag is the aforementioned tag for all such messages
! relating to the intercommunicator, st_intercomm1 is the inter-communicator, status and ierr are explained above
    CALL MPI_RECV(x1, 1, MPI_REAL, 0, tag, st_intercomm1, status, IERR)
    CALL MPI_RECV(y1, 1, MPI_REAL, 0, tag, st_intercomm1, status, IERR)

    CALL MPI_RECV(x2, 1, MPI_REAL, 1, tag, st_intercomm1, status, IERR)
    CALL MPI_RECV(y2, 1, MPI_REAL, 1, tag, st_intercomm1, status, IERR)

    CALL MPI_RECV(x3, 1, MPI_REAL, 2, tag, st_intercomm1, status, IERR)
    CALL MPI_RECV(y3, 1, MPI_REAL, 2, tag, st_intercomm1, status, IERR)

    CALL MPI_RECV(x4, 1, MPI_REAL, 3, tag, st_intercomm1, status, IERR)
    CALL MPI_RECV(y4, 1, MPI_REAL, 3, tag, st_intercomm1, status, IERR)

! Here, we calculate the particle's new position and record it in the txt file
! As mentioned earlier, each of the solvers calculates the vector field in one quadrant. This section
! tests what quadrant the particle is in, and then calculates its new position based on the corresponding vector field
    IF(particle_pos_x > 0 .AND. particle_pos_y > 0) THEN
        write(*,*) "0"
        particle_pos_x = particle_pos_x + 0.1*x1
        particle_pos_y = particle_pos_y + 0.1*y1
    ELSE IF(particle_pos_x < 0 .AND. particle_pos_y > 0) THEN
        write(*,*) "1"
        particle_pos_x = particle_pos_x + 0.1*x2
        particle_pos_y = particle_pos_y + 0.1*y2
    ELSE IF(particle_pos_x < 0 .AND. particle_pos_y < 0) THEN
        write(*,*) "2"
        particle_pos_x = particle_pos_x + 0.1*x3
        particle_pos_y = particle_pos_y + 0.1*y3
    ELSE
        write(*,*) "3"
        particle_pos_x = particle_pos_x + 0.1*x4
        particle_pos_y = particle_pos_y + 0.1*y4
    END IF

    WRITE(filetag,100) particle_pos_x, particle_pos_y, rank
        100 FORMAT (F10.4,",",F10.4,",",I0)
    curr_step = curr_step + 1
END DO

!Standard ending functions
CLOSE(filetag)
call MPI_FINALIZE(ierr)

END PROGRAM tracker
